T = int(input())

for tc in range(1, T + 1):
    N = int(input())

    # row: 각 행에 배치된 퀸의 열 위치를 저장하는 리스트
    # 예를 들어 row[i] = j 라면, i행 j열에 퀸이 있다는 의미미
    # 실제 값은 DFS 진행 중 결정됨
    row = [0] * N
    result = 0

    
    # n은 현재 퀸을 놓으려고 하는 행의 인덱스
    def dfs(n):
        global result

        # [종료 조건]
        # 만약 n이 N과 같다면, 
        if n == N:
            # 유효한 배치 방법을 찾았으므로, 1 증가
            result += 1
            # 현재 탐색 경로를 종료하고 이전 단계로 돌아감감
            return

        # [백트래킹]
        # 현재 n번째 행에 퀸을 놓을 수 있는 모든 열(i) 시도
        # i는 0부터 N-1까지의 값을 가집니다.
        for i in range(N):
            # n번째 행, i번째 열에 퀸을 배치
            row[n] = i

            # 현재 n번째 행에 놓은 퀸이 이전 행(0부터 n-1까지)에 놓인 퀸들과 충돌하는지 확인
            # j는 0부터 n-1까지의 이전 행들을 나타냄냄
            for j in range(n):
                # 충돌 조건 확인:
                # 1. row[n] == row[j]: 현재 퀸과 j번째 행의 퀸이 같은 열에 있는 경우 (수직 공격)
                # 2. abs(row[n] - row[j]) == abs(n - j):
                #    현재 퀸과 j번째 행의 퀸이 대각선상에 있는 경우 (대각선 공격)
                #    (행의 차이와 열의 차이의 절댓값이 같으면 대각선)
                if row[n] == row[j] or abs(row[n] - row[j]) == abs(n - j):
                    # 충돌이 발생하면, 현재 열(i)은 유효하지 않으므로
                    # 내부 for문을 중단하고 다음 열을 시도
                    break
            # 'break' 없이 정상적으로 모두 실행되었을 때만 실행
            # = 현재 n행 i열에 놓은 퀸이 이전 퀸들과 충돌하지 않는다는 의미
            else:
                # 충돌이 없으므로, 다음 행(n+1)에 퀸을 놓기 위해 재귀적으로 dfs 함수를 호출
                dfs(n + 1)

            # dfs(n+1) 호출이 끝나고 돌아오면, dfs(n)은 현재 n번째 행에서 아직 시도해보지 않은 다른 열 위치에 퀸을 놓아보는 것을 계속함
            # for i in range(N) 루프가 이 역할
            # 즉, 한 행에서 어떤 열에 퀸을 놓고 다음 행으로 넘어갔다가, 그 경로가 막히거나 모든 탐색을 마치고 돌아오면,
            # 원래 행으로 돌아와서 "아, 아까 그 열 말고 다른 열에 놔볼까?" 하면서 다른 선택지를 탐색
            # -> 백트래킹의 핵심 아이디어

    # 0번째 행부터 퀸 배치
    dfs(0)
    print(f'#{tc} {result}')